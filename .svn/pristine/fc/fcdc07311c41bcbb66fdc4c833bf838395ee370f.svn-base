#include "myfun.h"
#include "mygst.h"
#include "mytype.h"
#include <signal.h> 

static GMainLoop *loop; 
static PlayerDataPointer data;
static ParasPointer parameter; 

void 
saveStoppdPoint() {
  GstFormat fmt = GST_FORMAT_TIME; 
  gint64 current = -1; 
  gst_element_query_position(data->playbin2, &fmt, &current); 
  /*printf("time: %lu\n", current); */
  FILE *stoppedPointFile = NULL; 
  char *stoppedPointSrc =  concatenateName(parameter->workingDir, "stoppedPoint.txt"); 
  if((stoppedPointFile = fopen(stoppedPointSrc, "wt"))) {
    char buf[BUFSIZE]; 
    int gsecond = current / GST_SECOND;  
    sprintf(buf, "%d", gsecond); 
    fputs(buf, stoppedPointFile); 
    printf("time: %d\n", gsecond); 
    fflush(stoppedPointFile); 
    fclose(stoppedPointFile); 
  }
}

int 
loadStoppedPoint() {
  FILE *stoppedPointFile = NULL; 
  char *stoppedPointSrc = concatenateName(parameter->workingDir, "stoppedPoint.txt"); 
  gint64 current = 0; 
  int gsecond = 0; 
  if((stoppedPointFile = fopen(stoppedPointSrc, "rt"))) {
    char buf[BUFSIZE]; 
    if(fgets(buf, BUFSIZE, stoppedPointFile) != NULL) {
      sscanf(buf, "%d", &gsecond); 
    }
    fflush(stoppedPointFile); 
    fclose(stoppedPointFile); 
    fclose(fopen(stoppedPointSrc, "wt")); 
  }
  printf("loadStoppedPoint(): %d\n", gsecond); 
  return gsecond; 
}


void 
handle_kill(int sigNo) {
  if(sigNo == SIGINT || sigNo == SIGQUIT || sigNo == SIGTERM) {
    saveStoppdPoint(); 
    exit(0); 
  }
}

static gboolean 
bus_call(GstBus *bus, 
    GstMessage *msg, 
    gpointer pointer) {
  /*loop = (GMainLoop *)pointer; */

  switch(GST_MESSAGE_TYPE(msg)) {
    case GST_MESSAGE_EOS:  
      {
        g_print("End of stream\n"); 
        g_main_loop_quit(loop); 
        return TRUE; 
      }
    case GST_MESSAGE_ERROR: 
      {
        gchar *debug; 
        GError *error; 
        gst_message_parse_error(msg, &error, &debug); 
        g_free(debug);
        g_printerr("Error: %s\n", error->message);
        g_error_free(error); 
        /*  
            GstFormat fmt = GST_FORMAT_TIME; 
            gint64 current = -1; 
            gst_element_query_position(data->playbin2, &fmt, &current); 
            printf("time: %lu\n", current); 
            */ 
        /*
        /////////////////////////////
        signal(SIGINT, handle_kill); 
        signal(SIGQUIT, handle_kill); 
        signal(SIGTERM, handle_kill); 
        /////////////////////////////
        */
        saveStoppdPoint();
        g_main_loop_quit(loop);
        return TRUE;
      }
    default: 
      {
        break; 
      }
  }
  return TRUE;
}

int 
main(int argc, 
    char **argv) {
  GstBus *bus; 
  GstBus *playbin2Bus; 
  /*GMainLoop *loop; */
  char *mediaSrc = NULL;
  GstStateChangeReturn ret; 
  GstMessage *msg; 
  /*gint64 current = 0; */
  int gsecond = 0; 

  // 判断参数调用是否正确
  if(argc != 2) {
    g_printerr("Usage: %s <parameter-src>\n", argv[0]); 
    return -1; 
  } 

  /////////////////////////////
  signal(SIGINT, handle_kill); 
  signal(SIGQUIT, handle_kill); 
  signal(SIGTERM, handle_kill); 
  /////////////////////////////

  /*PlayerDataPointer data = (PlayerData *)malloc(sizeof(PlayerData)); */
  data = (PlayerData *)malloc(sizeof(PlayerData)); 
  /*ParasPointer parameter = (ParasPointer)malloc(sizeof(Parameter)); */
  parameter = (ParasPointer)malloc(sizeof(Parameter)); 
  initParameter(parameter, argv[1]); // 读入参数文件，初始化程序
  int isFirst = 1;  // 是否是程序运行后的第一次播放
  int shouldReplay = 0; 
  char *lastplayMediaName = NULL; 

  /* Initialize GStreamer */ 
  gst_init(&argc, &argv); 
  loop = g_main_loop_new(NULL, FALSE);

  initGstElement(data, parameter); 

  // 构造“日志空间”并且初始化
  RecordList records = NULL; 
  initRecords(&records); 
  createRecords(records, parameter->workingDir); 
  printRecords(records); 
  newLine(); 

  // 构造播放列表并且初始化
  PlayItemList playlist = NULL; 
  initPlaylist(&playlist); 
  newLine(); 

  // 构造插播列表并且初始化
  InsertionList insertions = NULL; 
  initInsertionList(&insertions); 
  newLine(); 

  bus = gst_pipeline_get_bus(GST_PIPELINE(data->pipeline)); 
  playbin2Bus = gst_element_get_bus(data->playbin2); 
  gst_bus_add_watch(bus, bus_call, loop); 
  /*gst_bus_add_watch(playbin2Bus, bus_call, loop); */
  gst_object_unref(bus); 

  // 循环播放
  while(1) {
    /*RecordList recordsCursor = records; */
    PlayItemList playlistCursor = playlist; 
    InsertionList insertionsCursor = insertions; 

    // 每次循环开始都去检测播放列表文件，生成新的播放列表
    createPlaylist(playlist, parameter->playlistSrc); 
    printf("Playlist: \n"); 
    printPlaylist(playlist); 
    newLine(); 

    // 对于在播放列表中但不存在于“日志空间”的媒体文件，在“日志空间”中增加其记录
    mergeRecords(records, playlist); 
    printf("Records: \n"); 
    printRecords(records); 
    newLine(); 

    // 如果是第一次进入循环，则判断是否要从上回程序退出的那个媒体文件开始播放
    if(isFirst && (gsecond = loadStoppedPoint()) && (lastplayMediaName = loadLastPlay(parameter->lastPlaySrc)) && isInPlaylist(playlist, lastplayMediaName)) {
      while(playlistCursor->next) {
        // 将游标移动到播放列表链表中媒体文件名为lastplayMediaName的节点的上一个节点
        if(!strcmp(playlistCursor->next->mediaName, lastplayMediaName)) {
          break; 
        } else {
          playlistCursor = playlistCursor->next; 
        }
      }
      shouldReplay = 1; 
      isFirst = 0;
    }

    // 顺序播放播放列表中的媒体文件
    while(playlistCursor->next) {
      playlistCursor = playlistCursor->next; 

      // 检测并生成插播列表
      createInsertionList(insertions, parameter->insertionsSrc);
      printf("Insertions: \n"); 
      printInsertionList(insertions); 
      // 优先播放插播列表
      while(insertionsCursor->next) {
        if(shouldReplay) {
          break; 
        }
        insertionsCursor = insertionsCursor->next; 
        mediaSrc = concatenateName(parameter->mediaDir, 
            insertionsCursor->mediaName);
        changeRecords(records, insertionsCursor->mediaName);  // 将该媒体文件的播放次数+1
        saveRecords(records, parameter->workingDir);          // 将“日志空间”保存到当天的日志文件
        saveLastPlay(parameter->lastPlaySrc, insertionsCursor->mediaName);  //将该媒体文件存为“最后播放”
        runPlaybin2(data, mediaSrc);  // 播放该媒体文件
        g_main_loop_run(loop); 
        gst_element_set_state(data->pipeline, GST_STATE_NULL);
      }
      mediaSrc = concatenateName(parameter->mediaDir, 
          playlistCursor->mediaName); 
      changeRecords(records, playlistCursor->mediaName);      // 将该媒体文件的播放次数+1
      saveRecords(records, parameter->workingDir);            // 将“日志空间”保存到当天的日志文件
      saveLastPlay(parameter->lastPlaySrc, playlistCursor->mediaName);  // 将该媒体文件存为“最后播放”
      runPlaybin2(data, mediaSrc);  // 播放该媒体文件 

      if(shouldReplay && gsecond) {
        printf("####replay####: %dseconds\n", gsecond); 
        GstFormat fmt = GST_FORMAT_TIME; 
        gint64 current = -1; 

        if(!gst_element_query_position(data->playbin2, &fmt, &current)) {
          g_printerr("Could not query current position.\n");
        }

        if(!GST_CLOCK_TIME_IS_VALID(data->duration)) {
          g_printerr("not valid\n"); 
          if(!gst_element_query_duration(data->playbin2, &fmt, &data->duration)) {
            g_printerr("Could not query current duration\n"); 
          }
        } 

        gst_element_seek_simple(data->playbin2, GST_FORMAT_TIME, 
            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, gsecond * GST_SECOND); 
        gsecond = 0; 
        shouldReplay = 0; 
      }
      g_main_loop_run(loop); 

      /*
         do {
         msg = gst_bus_timed_pop_filtered(bus, 100 * GST_MSECOND, 
         GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION); 
         if(msg != NULL) {
         handle_message(data, msg, loop); 
         } else {
         handle_time(data); 
         }
         }while(!data->terminate); 
         g_main_loop_run(loop); 
         if(data->terminate) 
         g_main_loop_quit(loop);
         */
      gst_element_set_state(data->pipeline, GST_STATE_NULL);
    }
  }
  gst_object_unref(GST_OBJECT(data->pipeline)); // 释放gstreamer的相关资源 

  return 0; 
}

