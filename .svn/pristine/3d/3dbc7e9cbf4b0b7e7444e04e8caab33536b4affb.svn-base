#include "myfun.h"
#include "mygst.h"
#include "mytype.h"
#include <signal.h> 
#include <pthread.h> 

static GMainLoop *loop; 
static PlayerDataPointer data;
static ParasPointer parameter; 
static GstBus *bus; 
static GstBus *playbin2Bus; 
static char *mediaSrc = NULL;
static GstStateChangeReturn ret; 
static GstMessage *msg; 
static int gsecond = 0; //记录程序被杀死时媒体文件播放了多少秒
static int isFirst = 1;  // 是否是程序运行后的第一次播放
static int shouldReplay = 0;  // 是否需要续播
static char *lastplayMediaName = NULL; 
static RecordList records = NULL; 
static PlayItemList playlist = NULL; 
static InsertionList insertions = NULL;
static pthread_t thread; 

static void handle_message (PlayerDataPointer data, GstMessage *msg) {
  GError *err;
  gchar *debug_info;

  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_ERROR:
      {
        gst_message_parse_error (msg, &err, &debug_info);
        g_printerr ("Error received from element %s: %s\n", GST_OBJECT_NAME (msg->src), err->message);
        g_printerr ("Debugging information: %s\n", debug_info ? debug_info : "none");
        g_clear_error (&err);
        g_free (debug_info);
        data->terminate = TRUE;
        break;
      }
    case GST_MESSAGE_EOS:
      {
        g_print ("End-Of-Stream reached.\n");
        data->terminate = TRUE;
        break;
      }
    case GST_MESSAGE_DURATION:
      {
        /* The duration has changed, mark the current one as invalid */
        data->duration = GST_CLOCK_TIME_NONE;
        break;
      }
    case GST_MESSAGE_STATE_CHANGED: 
      {
        GstState old_state, new_state, pending_state;
        gst_message_parse_state_changed (msg, &old_state, &new_state, &pending_state);
        if (GST_MESSAGE_SRC (msg) == GST_OBJECT (data->playbin2)) {
          g_print ("Pipeline state changed from %s to %s:\n",
              gst_element_state_get_name (old_state), gst_element_state_get_name (new_state));

          /* Remember whether we are in the PLAYING state or not */
          data->playing = (new_state == GST_STATE_PLAYING);

          if (data->playing) {
            /* We just moved to PLAYING. Check if seeking is possible */
            GstQuery *query;
            gint64 start, end;
            query = gst_query_new_seeking (GST_FORMAT_TIME);
            if (gst_element_query (data->playbin2, query)) {
              gst_query_parse_seeking (query, NULL, &data->seek_enabled, &start, &end);
              if (data->seek_enabled) {
                g_print ("Seeking is ENABLED from %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT "\n",
                    GST_TIME_ARGS (start), GST_TIME_ARGS (end));
              } else {
                g_print ("Seeking is DISABLED for this stream.\n");
              }
            }
            else {
              g_printerr ("Seeking query failed.");
            }
            gst_query_unref (query);
          }
        }
      } break;
    default:
      {
        /* We should not reach here */
        g_printerr ("Unexpected message received.\n");
        break;
      }
  }
  gst_message_unref (msg);
}

/* 
 * saveStoppdPoint: 保存断点，下次启动时自动播放
 */
void 
saveStoppdPoint() {
  GstFormat fmt = GST_FORMAT_TIME; 
  gint64 current = -1; 
  gst_element_query_position(data->playbin2, &fmt, &current); 
  FILE *stoppedPointFile = NULL; 
  char *stoppedPointSrc =  concatenateName(parameter->workingDir, "stoppedPoint.txt"); 
  if((stoppedPointFile = fopen(stoppedPointSrc, "wt"))) {
    char buf[BUFSIZE]; 
    int gsecond = current / GST_SECOND;  
    sprintf(buf, "%d", gsecond); 
    fputs(buf, stoppedPointFile); 
    printf("Save Stopped Point: %d\n", gsecond); 
    fflush(stoppedPointFile); 
    fclose(stoppedPointFile); 
  }
}

/*
 * loadStoppedPoint: 加载断点进度
 */
int 
loadStoppedPoint() {
  FILE *stoppedPointFile = NULL; 
  char *stoppedPointSrc = concatenateName(parameter->workingDir, "stoppedPoint.txt"); 
  gint64 current = 0; 
  int gsecond = 0; 
  if((stoppedPointFile = fopen(stoppedPointSrc, "rt"))) {
    char buf[BUFSIZE]; 
    if(fgets(buf, BUFSIZE, stoppedPointFile) != NULL) {
      sscanf(buf, "%d", &gsecond); 
    }
    fflush(stoppedPointFile); 
    fclose(stoppedPointFile); 
    fclose(fopen(stoppedPointSrc, "wt")); 
  }
  printf("Load Stopped Point: %d\n", gsecond); 
  return gsecond; 
}

/* 
 * handle_kill: 处理程序被杀死时所执行的代码
 */
void 
handle_kill(int sigNo) {
  if(sigNo == SIGINT || sigNo == SIGQUIT || sigNo == SIGTERM) {
    saveStoppdPoint(); 
    exit(0); 
  }
}

static gboolean 
bus_call(GstBus *bus, 
    GstMessage *msg, 
    gpointer pointer) {

  switch(GST_MESSAGE_TYPE(msg)) {
    case GST_MESSAGE_EOS:  
      {
        g_print("End of stream\n"); 
        g_main_loop_quit(loop); 
        return TRUE; 
      }
    case GST_MESSAGE_ERROR: 
      {
        gchar *debug; 
        GError *error; 
        gst_message_parse_error(msg, &error, &debug); 
        g_free(debug);
        g_printerr("Error: %s\n", error->message);
        g_error_free(error); 
        saveStoppdPoint();
        g_main_loop_quit(loop);
        return TRUE;
      }
    default: 
      {
        break; 
      }
  }
  return TRUE;
}

void * 
handle_save(void *ptr) {
  saveRecords(records, parameter->workingDir);          // 将“日志空间”保存到当天的日志文件

  return ((void *) 0); 
}

int 
main(int argc, 
    char **argv) {

  // 判断参数调用是否正确
  if(argc != 2) {
    g_printerr("Usage: %s <parameter-src>\n", argv[0]); 
    return -1; 
  } 


  // 关联结束程序的信号及其相应的函数
  /////////////////////////////
  signal(SIGINT, handle_kill); 
  signal(SIGQUIT, handle_kill); 
  signal(SIGTERM, handle_kill); 
  /////////////////////////////

  data = (PlayerData *)malloc(sizeof(PlayerData)); 
  parameter = (ParasPointer)malloc(sizeof(Parameter)); 
  initParameter(parameter, argv[1]); // 读入参数文件，初始化程序

  /* Initialize GStreamer */ 
  gst_init(&argc, &argv); 
  loop = g_main_loop_new(NULL, FALSE);

  initGstElement(data, parameter); 

  // 构造“日志空间”并且初始化
  initRecords(&records); 
  createRecords(records, parameter); 

  // 构造播放列表并且初始化
  initPlaylist(&playlist); 

  // 构造插播列表并且初始化
  initInsertionList(&insertions); 

  bus = gst_pipeline_get_bus(GST_PIPELINE(data->pipeline)); 
  /*playbin2Bus = gst_element_get_bus(data->playbin2); */
  gst_bus_add_watch(bus, bus_call, loop); 
  /*gst_bus_add_watch(playbin2Bus, bus_call, loop); */
  gst_object_unref(bus); 

  // 循环播放
  while(1) {
    PlayItemList playlistCursor = playlist; 
    InsertionList insertionsCursor = insertions; 

    // 每次循环开始都去检测播放列表文件，生成新的播放列表
    createPlaylist(playlist, parameter->playlistSrc); 

    // 对于在播放列表中但不存在于“日志空间”的媒体文件，在“日志空间”中增加其记录
    mergeRecords(records, playlist); 

    if((playlistCursor = checkPlaylist(playlist, parameter->mediaDir)) == NULL) {
      runPlaybin2(data, concatenateName("file://", parameter->fixedMedia)); 
      g_main_loop_run(loop); 
      gst_element_set_state(data->pipeline, GST_STATE_NULL); 
      continue; 
    }

    // 如果是第一次进入循环，则判断是否要从上回程序退出的那个媒体文件开始播放
    if(isFirst && (gsecond = loadStoppedPoint()) && (lastplayMediaName = loadLastPlay(parameter->lastPlaySrc)) && isInPlaylist(playlist, lastplayMediaName)) {
      while(playlistCursor->next) {
        // 将游标移动到播放列表链表中媒体文件名为lastplayMediaName的节点的上一个节点
        if(!strcmp(playlistCursor->next->mediaName, lastplayMediaName)) {
          break; 
        } else {
          playlistCursor = playlistCursor->next; 
        }
      }
      shouldReplay = 1;   // 需要续播
      isFirst = 0;
    }

    // 顺序播放播放列表中的媒体文件
    while(playlistCursor->next) {
      playlistCursor = playlistCursor->next; 

      // 检测并生成插播列表
      createInsertionList(insertions, parameter->insertionsSrc);
      // 优先播放插播列表
      while(insertionsCursor->next) {
        if(shouldReplay) {
          break; 
        }
        insertionsCursor = insertionsCursor->next; 
        mediaSrc = concatenateName(parameter->mediaDir, 
            insertionsCursor->mediaName);
        changeRecords(records, insertionsCursor->mediaName);  // 将该媒体文件的播放次数+1
        saveLastPlay(parameter->lastPlaySrc, insertionsCursor->mediaName);  //将该媒体文件存为“最后播放”
        pthread_create(&thread, NULL, &handle_save, NULL); 
        pthread_join(thread, NULL); 
        runPlaybin2(data, mediaSrc);  // 播放该媒体文件
        g_main_loop_run(loop); 
        gst_element_set_state(data->pipeline, GST_STATE_NULL);
      }

      mediaSrc = concatenateName(parameter->mediaDir, 
          playlistCursor->mediaName); 
      changeRecords(records, playlistCursor->mediaName);      // 将该媒体文件的播放次数+1
      saveLastPlay(parameter->lastPlaySrc, playlistCursor->mediaName);  // 将该媒体文件存为“最后播放”
      pthread_create(&thread, NULL, &handle_save, NULL); 
      pthread_join(thread, NULL); 
      runPlaybin2(data, mediaSrc);  // 播放该媒体文件 

      // 执行续播操作
      if(shouldReplay && gsecond) {
        printf("####replay####: %dseconds\n", gsecond); 
        do {
          msg = gst_bus_timed_pop_filtered(bus, 100 * GST_MSECOND, 
              GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION); 
          if(msg != NULL) {
            handle_message(data, msg); 
          } else {
            if (data->playing) {
              if(data->seek_enabled && !data->seek_done) {
                gst_element_seek_simple(data->playbin2, GST_FORMAT_TIME, 
                    GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, gsecond * GST_SECOND); 
                data->seek_done = TRUE; 
              }
              gsecond = 0; 
              shouldReplay = 0; 
            }
          }
        } while(!data->terminate && shouldReplay);
      }
      g_main_loop_run(loop); 
      gst_element_set_state(data->pipeline, GST_STATE_NULL);
    }
  }
  gst_object_unref(GST_OBJECT(data->pipeline)); // 释放gstreamer的相关资源 

  return 0; 
}

